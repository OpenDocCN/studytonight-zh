# 使用事件对象的线程同步

> 原文：<https://www.studytonight.com/python/python-threading-event-object>

是时候了解更多 python 中的线程了。在本教程中，我们将介绍一个重要的类，`Event`类，它在 python 中用于线程同步。

这个类通过生成事件用于线程间通信。

* * *

## Python 多线程:事件对象

事件类对象提供了一种简单的机制，用于线程之间的通信，其中一个线程发出事件信号，而其他线程等待它。因此，当一个用于产生信号的线程产生信号时，等待的线程就会被激活。

一个内部标志被称为**事件标志**的事件对象使用，该标志可以使用`set()`方法设置为真，并且可以使用`clear()`方法重置为假。

`wait()`方法阻塞一个线程，直到它正在等待的事件标志被任何其他线程设置为真..

以下是与事件对象一起使用的有用函数:

### 初始化事件对象

我们可以如下初始化事件对象:

```
import threading

are_you_coming = threading.Event()
```

当我们像这样初始化一个事件对象时，默认情况下内部标志被设置为**假**。

* * *

### `isSet()`方法

当且仅当内部标志为真时，此方法返回真。

```
import threading

are_you_coming = threading.Event()
print(are_you_coming.isSet())
```

错误的

* * *

### `set()`方法

当对任何事件对象调用此方法时，内部标志被设置为 true。一旦为任何事件调用`set()`方法，所有等待它的线程都会被唤醒。

* * *

### `clear()`方法

此方法将内部标志重置为 false。随后，对调用`clear()`的事件调用`wait()`的线程将阻塞，直到内部标志再次不为真。

* * *

### `wait([timeout])`方法

当我们必须让任何线程等待一个事件时，我们可以这样做:在内部标志设置为 false 的事件上调用这个方法，这样做将阻塞线程，直到事件的内部标志为 true。

如果入口时内部标志为真，则线程永远不会被阻塞。否则，它将被阻止，直到另一个线程调用`set()`将标志设置为真，或者直到可选超时发生。timeout 参数以秒为单位指定操作超时。

* * *

## 举个例子

让我们有一个简单的代码示例来演示`Event`类对象的用法。

在下面的代码中，我们将创建一个线程，让它等待一个由**主**线程生成的事件，释放第一个线程。

在上面的程序中，我们也使用了`wait()`方法的`timeout`属性。

当线程调用`wait([timeout])`方法时，如果在接收事件对象时释放等待，则该方法返回布尔值**真**，否则如果由于超时而释放等待，则该方法返回**假**。

为了测试这一点，更改第 18 行作为参数`args=(e,4)`发送的超时值，并使其小于睡眠时间，例如，将超时值设置为 2 并查看输出。

* * *