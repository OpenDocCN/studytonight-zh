# 利用 python 中的列表元素

> 原文：<https://www.studytonight.com/python/utilising-list-elements>

到目前为止，我们已经*创建了一个列表*并且*访问了该列表的单个元素*，现在是时候学习如何通过使用循环迭代使用一个[列表](lists-in-python)中的所有元素了。

当您有一个包含一百或一千个元素的列表，并且您想要访问其中的几个或所有元素来对它们执行一些操作或计算时，使用索引号来访问所有元素将是非常忙碌的。在这种情况下，我们使用迭代的方法，来迭代所有的列表项。为了理解如何迭代列表元素，我们将使用循环。别担心循环会在[循环教程](/python/looping-in-python)中详细介绍。

* * *

## 循环介绍

循环用于完成冗余和重复的任务。

#### 使用`for`循环

让我们从`for`循环开始。为了迭代一个列表，一个`for`循环需要两样东西——首先，一个引用变量来存储被迭代的元素，其次，一个源(`list`或者一个`range()`，就像前面的例子一样。当`for`循环执行时，**源**的元素被一个接一个地复制到**参考变量**中，以便在循环中使用(执行操作)。例如，

```py
for x in range(0,5):
	print (x)
```

0 1 2 3 4

在上面的例子中，`x`是我们的参考变量，其中，`range(0, 5)`中的每个元素都被迭代地(一个接一个地)存储起来，非常简单。

另外，你必须知道`range(0, 5)`返回一个包含元素 0 到 4 的`list`。

* * *

#### 使用`while`循环

另一种迭代方式是使用`while`循环。`while`循环需要一个条件才能运行。循环继续迭代，直到条件为**真**。一旦变为**假**，循环就会终止。例如，

```py
i = 0
while i < 5:
	print (i);
	i = i+1;
```

0 1 2 3 4

您可以看到两个循环返回了相同的输出，但是`while`循环使用了条件`i < 5`来获得输出。简单的英文，暗示着*当`i`小于`5`时，继续打印`i`，继续递增`i`“*的值。你知道为什么每次打印`i`的值后，我们都会增加它的值吗？嗯，这是因为如果我们没有增加它的值，该值将保持与最初声明的相同，即`i = 0`，并且条件`i < 5`将始终为**真**，因此循环永远不会结束。这种情况导致了我们所说的**无限循环**。

* * *

## 使用带列表的循环

关于循环已经讲得够多了，现在让我们看看如何使用它们来访问列表元素。取一个包含任何类型元素的列表。现在，使用`for`循环，我们可以非常容易地访问列表的每个元素。为了访问元素，我们必须使用**参考变量**和我们的列表变量作为**源**。

```py
myList = ['Last Of Us', 'Doom', 'Dota', 'Halo', ' ']
for x in myList:
	print (x)
```

我们最后的末日多塔光环

[现场示例→](/code/python/iterating-list-for-while-loop.php)

* * *

### 同时迭代两个列表- `zip()`方法

假设有两个列表，您希望将第一个列表的每个元素顺序添加到第二个列表的每个元素中，并将其保存到第三个(空)列表中。

我们可以通过执行如下代码所示的`while`循环来实现这一点，但这不是正确的方法。

```py
i = 0
A = [1, 2, 3, 4]
B = [5, 6, 7, 8]
C = []
while i < len(A):
    C.append(A[i]+B[i]);
    i=i+1 
```

在上面的代码中，我们将不得不添加许多条件来确保它一直无错误地运行。例如，如果两个列表的大小不一样怎么办？

在这种情况下，我们必须做一些不同的事情，因为我们必须一起迭代两个不同列表的元素。这可以使用功能`zip()`来完成。

假设这两个列表是，

```py
>>> A = [9, 8, 7, 6, 5]
>>> B = [3, 4, 5, 6, 7]
```

然后，让我们创建一个空列表来保存结果。

```py
>>> C = []
```

那么迭代过程将需要两个引用变量，每个列表一个。

```py
for x, y in zip(A, B):
	C.append(x+y)
```

[现场示例→](/code/python/zip-function-to-iterate-two-lists.php)

`zip()`函数可以接受任意数量的列表参数。在这种情况下，我们已经通过了两个列表 **A** 和 **B** 。由于 A 和 B 都有 5 个元素，因此`zip()`将使循环迭代 5 次。但是，如果两个列表的元素数量不同呢？假设 A 有`n`元素，B 有`m`元素，如果`m < n`那么`zip()`会循环`m`次，否则`n`次。

解决这个问题的另一种方法可能是使用列表 A 和 b 的索引号。

```py
for i in range(0,5):
	C.append(A[i]+B[i]) 
```

虽然在使用这种技术时，有必要在追加之前知道这两个列表的大小，但是前面的方法(`zip`函数)几乎可以在任何情况下使用。

* * *

* * *