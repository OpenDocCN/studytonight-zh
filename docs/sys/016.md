# 调度算法的比较

> 原文：<https://www.studytonight.com/operating-system/comparision-scheduling-algorithms>

到目前为止，您一定已经了解了 CPU 如何应用不同的调度算法来调度进程。现在，让我们检查一下到目前为止我们所研究的每种调度算法的优缺点。

* * *

## 先到先得

先说**优势:**

*   [FCFS 算法](first-come-first-serve)不包含任何复杂的逻辑，只是将进程请求放入队列中，逐一执行。
*   因此，FCFS 非常简单，易于实现。
*   最终，每个进程都有机会运行，所以不会出现饥饿。

是时候**劣势了:**

*   没有优先选择进程的选项。如果一个进程被启动，那么CPU执行该进程，直到它结束。
*   因为没有先发制人，如果一个进程执行了很长时间，队列后面的进程要等很长时间才有机会执行。

* * *

## 最短工作优先(SJF)

从[最短作业优先](shortest-job-first)调度算法的**优势:**开始。

*   根据定义，先执行短流程，然后执行长流程。
*   吞吐量增加是因为可以在更短的时间内执行更多的进程。

而**的缺点:**

*   一个进程所花费的时间必须事先被CPU知道，这是不可能的。
*   更长的进程会有更多的等待时间，最终它们会挨饿。

> **注:**抢占式最短作业优先调度将与 SJF 调度有相同的优缺点。

* * *

## 循环赛

以下是使用[循环调度](round-robin-scheduling)的一些**优势:**:

*   每个进程都由CPU在固定的时间段内提供服务，因此所有进程都被赋予相同的优先级。
*   饥饿不会发生，因为对于每个循环周期，每个进程都有固定的执行时间。没有一个过程被落下。

**缺点来了:**

*   RR 中的吞吐量很大程度上取决于时间量长度的选择。如果时间量比需要的长，它往往会表现出与 FCFS 相同的行为。
*   如果时间量比需要的短，那么CPU从一个进程切换到另一个进程的次数就会增加。这导致了CPU效率的降低。

* * *

## 基于优先级的调度

**[优先调度](priority-scheduling)的优势**:

*   进程的优先级可以根据内存需求、时间需求或用户偏好来选择。例如，高端游戏会有更好的图形，这意味着游戏中更新屏幕的过程会有更高的优先级，以实现更好的图形性能。

一些**缺点:**

*   需要第二调度算法来调度具有相同优先级的进程。
*   在抢占式优先级调度中，优先级较高的进程可以先于已经在执行的优先级较低的进程执行。如果低优先级进程一直等待高优先级进程，就会出现饥饿。

* * *

### 调度算法在不同情况下的使用

每种调度算法都有一种它是最佳选择的情况。让我们看看不同的这种情况:

#### 情况 1:

传入的流程很短，不需要流程以特定的顺序执行。

在这种情况下，与 SJF 和 RR 相比，FCFS 的效果最好，因为流程很短，这意味着没有流程会等待更长的时间。当一个个进程被执行时，每个进程最终都会被执行。

#### 情况 2:

流程是长流程和短流程的混合，只有在给定时间内成功执行所有流程，任务才能完成。

循环调度在这里工作效率很高，因为它不会导致饥饿，并且为每个进程提供相等的时间量。

#### 情况 3:

这些进程混合了基于用户和基于内核的进程。

在这种情况下，基于优先级的调度有效，因为与基于用户的进程相比，基于内核的进程通常具有更高的优先级。

例如，调度程序本身是一个基于内核的进程，它应该首先运行，这样它就可以调度其他进程。

* * *

* * *