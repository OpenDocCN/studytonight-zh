# 什么是读写器问题？

> 原文：<https://www.studytonight.com/operating-system/readers-writer-problem>

读写器问题是另一个经典同步问题的例子。这个问题有许多变体，下面将研究其中一种。

* * *

### 问题陈述

有一个共享资源应该被多个进程访问。在这种情况下有两种类型的进程。他们是**读取器**和**写入器**。任意数量的**读取器**可以同时从共享资源读取，但是只有一个**写入器**可以写入共享资源。当**写入器**向资源写入数据时，没有其他进程可以访问资源。如果当时有非零数量的读取器访问资源，则**写入程序**无法写入资源。

* * *

## 解决方案

从上面的问题陈述中，很明显读取器比作者有更高的优先权。如果编写器想要写入资源，它必须等到当前没有读取器访问该资源。

这里，我们使用一个**互斥体** `m`和一个**信号量** `w`。整数变量`read_count`用于维护当前访问资源的读取器数量。变量`read_count`被初始化为`0`。`1`的值最初赋予`m`和`w`。

我们使用互斥体`m`使进程在更新`read_count`变量时获取和释放锁，而不是让进程获取共享资源的锁。

**编写器**进程的代码如下:

```c
while(TRUE) 
{
    wait(w);

   /* perform the write operation */

   signal(w);
}
```

并且，**阅读器**进程的代码如下所示:

```c
while(TRUE) 
{
    //acquire lock
    wait(m);
    read_count++;
    if(read_count == 1)
        wait(w);

    //release lock  
    signal(m);  

    /* perform the reading operation */

    // acquire lock
    wait(m);   
    read_count--;
    if(read_count == 0)
        signal(w);

    // release lock
    signal(m);  
} 
```

* * *

### 这是未编码的代码(已解释)

*   如上面针对编写器的代码所示，编写器只是等待 **w** 信号量，直到有机会写入资源。
*   在执行写操作之后，它递增 **w** ，以便下一个写入器可以访问资源。
*   另一方面，在读取器的代码中，每当通过进程更新 **read_count** 时，获取锁。
*   当读取器想要访问资源时，它首先递增 **read_count** 值，然后访问资源，然后递减 **read_count** 值。
*   进入临界区的第一个读取器和退出临界区的最后一个读取器使用信号量 **w** 。
*   这样做的原因是，当第一批读取器进入关键部分时，作者被阻止访问资源。现在只有新读取器才能访问该资源。
*   类似地，当最后一个读取器退出临界区时，它使用 **w** 信号量向写入器发出信号，因为现在没有读取器，写入器可以有机会访问资源。

* * *

* * *