# 信号量介绍

> 原文：<https://www.studytonight.com/operating-system/introduction-to-semaphores>

1965 年，Dijkstra 提出了一种新的非常重要的管理并发进程的技术，通过使用一个简单的整数变量值来同步交互进程的进度。这个整数变量被称为**信号量**。所以它基本上是一个同步工具，只能通过两个低标准的原子操作来访问，**等待**和**信号**分别由`P(S)`和`V(S)`指定。

简单来说，**信号量**是一个只能保存非负整数值的变量，由所有线程共享，操作**等待**和**信号**，工作如下:

```
P(S): if S >= 1 then S := S - 1
      else <block and enqueue the process>;

V(S): if <some process is blocked on the queue>
        then <unblock a process>
      else S := S + 1;
```

**等待**和**信号**的经典定义是:

*   **等待**:一旦变得非负(大于或等于`1`)，该操作就递减其参数`S`的值。此操作主要帮助您控制任务进入关键部分。在负值或零值的情况下，不执行任何操作。`wait()`手术最初被称为 P；所以也被称为 **P(S)操作**。等待操作的定义如下:

```
wait(S)
{ 
    while (S<=0);//no operation
    S--;
}
```

<u>**注:**</u>

当一个进程修改一个信号量的值时，没有其他进程可以同时修改同一个信号量的值。在上述情况下，必须不间断地执行整数值 S(S<=0)以及可能的修改 S。

*   **信号**:增加其参数`S`的值，因为队列中不再有进程被阻塞。此操作主要用于控制任务从关键部分的退出。`signal()`手术最初称为 V；所以也被称为 **V(S)操作**。信号操作的定义如下:

```
signal(S)
{
S++;
}
```

此外，注意在`wait()`和`signal()`操作中对信号量整数值的所有修改必须不可分割地执行。

## 信号量的性质

1.  很简单，总是有一个非负的整数值。

2.  适用于许多进程。

3.  可以有许多不同的临界区，有不同的信号量。

4.  每个关键部分都有唯一的访问信号量。

5.  如果需要，可以允许多个进程同时进入关键部分。

我们现在将介绍操作系统中信号量的类型；

## 信号量的类型

信号量在操作系统中主要有两种类型:

1.  **二进制信号量:**

    这是一种用于实现互斥的特殊形式的信号量，因此它通常被称为**互斥体**。二进制信号量被初始化为`1`，并且在程序执行期间只取值`0`和`1`。在二进制信号量中，只有当信号量的值= 1 时，等待操作才有效，当信号量= 0 时，信号操作成功。二进制信号量比计数信号量更容易实现。

2.  **计数信号量:**

    这些用于实现**有界并发**。计数信号量可以覆盖一个**不受限制的域**。这些可用于控制对由有限数量的实例组成的给定资源的访问。这里信号量计数用于指示可用资源的数量。如果添加了资源，那么信号量计数会自动递增，如果移除了资源，则计数会递减。计数信号量没有互斥。

## 使用示例

这是一个简单的分步实现，涉及信号量的声明和使用。

```
Shared var mutex: semaphore = 1;
Process i
    begin
    .
    .
    P(mutex);
    execute CS;
    V(mutex);
    .
    .
    End;
```

## 信号量的优势

使用信号量的好处如下:

*   在信号量的帮助下，资源得到了灵活的管理。

*   信号量是独立于机器的，它们应该在微内核的独立于机器的代码中运行。

*   信号量不允许多个进程进入临界区。

*   它们允许多个线程访问关键部分。

*   由于信号量严格遵循互斥原则，因此它们比其他一些同步方法更有效。

*   信号量中的资源不会因为信号量中的繁忙等待而浪费，因为处理器时间不会不必要地浪费在检查是否满足任何条件以允许进程访问关键部分上。

## 信号量的缺点

*   最大的限制之一是信号量可能导致优先级反转；其中低优先级进程可以首先访问关键部分，而高优先级进程可以稍后访问关键部分。

*   为了避免信号量中的死锁，等待和信号操作需要以正确的顺序执行。

*   大规模使用信号量是不切实际的；因为它们的使用导致模块性的丧失，这是因为 wait()和 signal()操作阻止了系统结构化布局的创建。

*   它们的使用并没有强制执行，只是按照惯例。

*   如果使用不当，进程可能会无限期阻塞。这样的情况叫做**死锁**。在接下来的课程中，我们将详细研究死锁。

* * *

* * *