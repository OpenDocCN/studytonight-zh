# 什么是线程？

> 原文:[https://www . study south . com/operating-system/多线程](https://www.studytonight.com/operating-system/multithreading)

**Thread** 是一个执行单元，由自己的程序计数器、栈和一组寄存器组成，其中程序计数器主要跟踪下一条执行的指令，一组寄存器主要保存其当前的工作变量，栈主要包含执行历史

线程也被称为轻量级进程。线程是通过并行性提高应用程序性能的一种流行方式。线程主要用于表示软件方法，以便通过减少线程开销来提高操作系统的性能，线程开销主要相当于经典进程。

中央处理器在线程之间快速来回切换，给人一种线程并行运行的错觉。

因为每个线程都有自己独立的进程执行资源；因此，可以通过增加线程数量来并行执行多个进程。

这里需要注意的是，每个线程只属于一个进程，在一个进程之外不存在线程。每个线程基本上分别代表控制流。在网络服务器和 web 服务器的实现中，线程已经被成功使用。线程为应用程序在共享内存多处理器上的并行执行提供了合适的基础。

下图显示了单线程和多线程进程的工作情况:

![What are threads](../Images/0488a98686b1725e58782d5f8f845d95.png)

在继续之前，让我们先了解一下进程和线程之间的区别。

| 过程 | 线 |
| --- | --- |
| 进程只是指任何正在执行的程序。 | 线程只是指进程的一部分。 |
| 这个过程消耗更多的资源 | 线程消耗更少的资源。 |
| 这个过程需要更多的时间来创造。 | 线程比进程需要更少的创建时间。 |
| 这个过程是一个重量级的过程 | 线程被称为轻量级进程 |
| 终止该过程需要更多时间 | 线程终止的时间更短。 |
| 流程有独立的数据和代码段 | 一个线程主要共享数据段、代码段、文件等。它的对等线程。 |
| 这个过程需要更多的时间进行上下文切换。 | 线程切换上下文花费的时间更少。 |
| 与线程相比，进程之间的通信需要更多的时间。 | 与进程相比，线程之间的通信需要更少的时间。 |
| 由于某种原因，如果一个进程被阻塞，那么剩下的进程可以继续执行 | 万一用户级线程被阻塞，它的所有对等线程也会被阻塞。 |

## 螺纹的优点

螺纹的一些优点如下:

1.  响应性

2.  资源共享，因此可以更好地利用资源。

3.  经济。创建和管理线程变得更加容易。

4.  可扩展性。一个线程运行在一个 CPU 上。在多线程进程中，线程可以分布在一系列处理器上进行扩展。

5.  上下文切换是平滑的。上下文切换是指中央处理器从一个任务切换到另一个任务所遵循的过程。

6.  提高系统的吞吐量。我们举一个例子:假设一个进程被分成多个线程，每个线程的功能被认为是一个作业，那么单位时间内完成的作业数量就会增加，进而导致系统吞吐量的增加。

## 螺纹类型

有两种类型的线程:

1.  用户线程

2.  内核线程

**用户线程**在内核之上，没有内核支持。这些是应用程序程序员在程序中使用的线程。

**内核线程**在操作系统本身的内核中得到支持。所有现代操作系统都支持内核级线程，允许内核同时执行多个任务和/或同时服务多个内核系统调用。

现在让我们了解用户级线程和内核级线程之间的基本区别:

| 用户级线程 | 内核级线程 |
| --- | --- |
| 这些线程由用户实现。 | 这些线程由操作系统实现 |
| 操作系统无法识别这些线程， | 这些线程被操作系统识别， |
| 在用户级线程中，上下文切换不需要硬件支持。 | 在内核级线程中，需要硬件支持。 |
| 这些线程主要设计为依赖线程。 | 这些线程主要设计为独立的线程。 |
| 在用户级线程中，如果一个用户级线程执行阻塞操作，那么整个进程都将被阻塞。 | 另一方面，如果一个内核线程执行阻塞操作，那么另一个线程可以继续执行。 |
| 用户级线程的例子:Java 线程，POSIX 线程。 | 内核级线程的例子:窗口 Solaris。 |
| 用户级线程的实现由一个线程库完成，并且很容易。 | 而内核级线程的实现是由操作系统完成的，并且很复杂。 |
| 这个线程本质上是通用的，可以在任何操作系统上运行。 | 这是特定于操作系统的。 |

## 多线程模型

用户线程必须通过以下策略之一映射到内核线程:

*   多对一模式

*   一对一模式

*   多对多模型

### 多对一模式

*   在**多对一**模型中，许多用户级线程都被映射到一个内核线程上。

*   线程管理由用户空间中的线程库处理，这在本质上是高效的。

*   在这种情况下，如果用户级线程库在操作系统中以某种系统不支持的方式实现，那么内核线程使用这种多对一的关系模型。

![Many to One thread model](../Images/ac8b7c0e55aecae7a5d04b607ee19fa6.png)

### 一对一模式

*   **一对一**模型创建一个单独的内核线程来处理每个用户线程。

*   该模型的大多数实现都对可以创建的线程数量进行了限制。

*   从 95 到 XP 的 Linux 和 Windows 实现了线程的一对一模型。

*   该模型比多对一模型提供更多的并发性。

![One to One thread model](../Images/edb6600ae498af7c88fd2f699d58efae.png)

### 多对多模型

*   **多对多**模型将任意数量的用户线程复用到相同或更少数量的内核线程上，结合了一对一和多对一模型的最佳特性。

*   用户可以创建任意数量的线程。

*   阻止内核系统调用不会阻止整个进程。

*   进程可以在多个处理器上分割。

![Many to Many thread model](../Images/0426f7ac18540992dc4a527fe44c7064.png)

## 什么是线程库？

线程库为程序员提供了创建和管理线程的 API。

线程库可以在用户空间或内核空间中实现。用户空间涉及仅在用户空间内实现的 API 函数，没有内核支持。内核空间涉及系统调用，需要一个支持线程库的内核。

### 三种类型的螺纹

1.  **POSIX Pideds**可以作为用户或内核库提供，作为 POSix 标准的扩展。

2.  **Win32 线程**在 Windows 系统上作为内核级库提供。

3.  **Java 线程**:由于 Java 一般运行在 Java 虚拟机上，线程的实现是基于 JVM 运行在什么操作系统和硬件上的，也就是说，根据系统的不同，要么是 Pitheads，要么是 Win32 线程。

## 多线程问题

下面我们提到了几个与多线程相关的问题。嗯，这是一句老话，*一切美好的事物，都是有代价的。*

#### 线程取消

线程取消意味着在线程完成工作之前终止它。对此可以有两种方法，一种是**异步取消**，立即终止目标线程。另一个是**延迟取消**允许目标线程定期检查是否应该取消。

#### 信号处理

在 UNIX 系统中，信号用于通知进程某个特定事件已经发生。现在，当多线程进程接收到一个信号时，它必须被传递给哪个线程？它可以传递给所有线程或单个线程。

#### fork()系统调用

fork()是在内核中执行的系统调用，进程通过它创建自己的副本。现在多线程进程的问题是，如果一个线程分叉，整个进程会不会被复制？

#### 安全问题

是的，由于多线程之间资源的广泛共享，可能会有安全问题。

在多线程进程中，您可能会面临许多其他问题，但是有合适的解决方案可供使用。在这里指出一些问题只是为了研究硬币的两面。

* * *

* * *