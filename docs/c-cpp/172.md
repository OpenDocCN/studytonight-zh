# C++ 中的引用

> 原文：<https://www.studytonight.com/cpp/references-in-cpp.php>

引用就像自动取消引用的常量指针。这是给现有存储的新名称。因此，当您访问引用时，您实际上是在访问该存储。

```cpp
int main()
{ 
    int y=10;
    int &r = y;  // r is a reference to int y
    cout << r;
} 
```

Ten

不需要使用`*`来取消引用引用变量。

* * *

## 引用和指针的区别

| 参考 | 两颗北极指极星 |
| --- | --- |
| 创建引用时必须对其进行初始化。 | 指针可以随时初始化。 |
| 一旦初始化，我们就不能重新初始化引用。 | 指针可以被重新初始化任何次数。 |
| 您永远不能有空引用。 | 指针可以为空。 |
| 引用被自动取消引用。 | `*`用于取消引用指针。 |

* * *

## 函数中的引用

引用通常用于函数参数列表和函数返回值，就像指针一样。

### 在函数中使用引用的规则

1.  当我们在参数列表中使用引用时，我们必须记住，对函数内部引用的任何更改都会导致函数外部原始参数的更改。
2.  当我们从函数中返回一个引用时，您应该看到，当 fnction 结束时，无论该引用连接到什么，都不应该超出范围。要么使**全局**或**静态**

* * *

### 解释引用使用的示例

下面我们有一个简单的代码示例来解释 C++ 中引用的使用，

```cpp
 int* first (int* x)
{ 
    (*x++);
    return x;   // SAFE, x is outside this scope
}

int& second (int& x)
{ 
    x++;
    return x;   // SAFE, x is outside this scope
}

int& third ()
{ 
    int q;
    return q;   // ERROR, scope of q ends here
}

int& fourth ()
{ 
    static int x;
    return x;   // SAFE, x is static, hence lives till the end.
}

int main()
{
    int a=0;
    first(&a);   // UGLY and explicit
    second(a);   // CLEAN and hidden
} 
```

在上面的程序中，我们有四个不同的功能。

*   **first()** 以一个指针作为参数，返回一个指针，就可以了。返回的指针指向在 first()之外声明的变量，因此即使在 first()结束后它也将有效。

*   同样的，**秒()**也会好好工作。返回的引用连接到有效存储，在这种情况下是`int a`。

*   但是在 **third()** 的情况下，我们在函数内部声明了一个变量`q`，并试图返回一个与之相连的引用。但是一旦函数 third()结束，局部变量 q 就会被销毁，因此不会返回任何东西。

*   为了解决上述问题，我们在函数**第四个()**中将 x 设为**静态**，给它一个寿命，直到 main()结束，因此现在连接到 x 的引用在返回时将是有效的。

* * *

## C++ 中的常量引用

Const reference 用于函数参数中，以防止函数更改参数。

```cpp
void g(const int& x)
{ 
    x++; 
}   // ERROR

int main()
{
    int i=10;
    g(i);
}
```

我们无法更改函数中的参数，因为它是作为常量引用传递的。

* * *

### 参数传递指南

通常**按值调用**在函数调用期间使用，只是为了防止我们的对象或变量被更改或修改，但是每当我们按值传递参数时，它的新副本就会被创建。如果我们将一个对象作为参数传递，那么就会创建该对象的副本(调用构造器和析构器)，这会影响效率。

因此，我们必须使用**常量引用**类型参数。当我们使用 const reference 时，只有一个地址在栈上传递，它在函数内部使用，函数不能改变我们的参数，因为它是 const 类型的。

因此，使用 const 引用类型参数减少了开销，也避免了我们的参数被更改。

* * *

* * *